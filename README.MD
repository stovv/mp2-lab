# Реализация стека на линейном односвязном списке 

**Содержание:**

- [Постановка задачи](https://github.com/stovv/mp2-lab#Постановка-задачи)
- [Руководство пользователя](https://github.com/stovv/mp2-lab#Руководство-пользователя)
- [Руководство программиста](https://github.com/stovv/mp2-lab#Руководство-программиста)
	- [Используемые инструменты](https://github.com/stovv/mp2-lab#Используемые-инструменты)
	- [Общая структура проекта](https://github.com/stovv/mp2-lab#Общая-структура-проекта)
	- [Описание структуры программы](https://github.com/stovv/mp2-lab#Описание-структуры-программы)
	- [Описание структур данных](https://github.com/stovv/mp2-lab#Описание-структур-данных)
		- [Структура данных "список"](https://github.com/stovv/mp2-lab#Структура-данных-список)
		- [Структура данных "стек"](https://github.com/stovv/mp2-lab#Структура-данных-стек)
	- [Описание алгоритмов](https://github.com/stovv/mp2-lab#Описание-алгоритмов)
		- [Алгоритм перевода в постфиксную запись](https://github.com/stovv/mp2-lab#Алгоритм-перевода-в-постфиксную-запись)
		- [Алгоритм подсчета выражения в постфиксной записи](https://github.com/stovv/mp2-lab#Алгоритм-подсчета-выражения-в-постфиксной-записи)
- [Заключение](https://github.com/stovv/mp2-lab#Заключение)
- [Литература](https://github.com/stovv/mp2-lab#Литература)
 
## Постановка задачи
**Цель данной лабораторной работы** — разработать на языке программирования С++ статическую библиотеку, реализующую динамическую структуру данных — стек, основанный на динамической структуре — список. 

 
В качестве примера реализации стеков, разработать алгоритм преобразования инфиксной записи арифметических выражений в постфиксную. Создать консольное приложение, демонстрирующее работу алгоритма, где входные данные — арифметическое символьное выражение в инфиксном виде и значения каждого параметра, а результат — запись исходного арифметического символьного выражения в постфиксном виде, численный результат.

Написать консольные приложения для демонстрации работы списков и стеков.

## Руководство пользователя
### *Запуск приложения и ввод данных*

Данная программа предназначена для перевода символьного арифметического выражения из инфиксной записи в постфиксную и последующего вычисления результата на основе данных о каждой символьной переменной, введенных пользователем.

Чтобы запустить программу, необходимо открыть исполняемый файл `sample_list.exe` и далее следовать инструкциям программы.

Пример:

1. Введите арифметическое выражение и нажмите клавишу "Ввод" и увидите постфиксную форму выражения
![input](/img/input.PNG)
2. Введите значение каждой из символьных переменных, нажимая клавишу "Ввод" после каждого введенного значения.
3. ![2](/img/2.PNG)
4. Получите преобразованное выражение и численный результат.
![end](/img/end.PNG)

Для завершения работы нажмите любую клавишу.


## Руководство программиста 

### *Используемые инструменты*

В ходе лабораторной работы использовались следующие инструменты:

- Система контроля версий Git. 
- Среда разработки Microsoft Visual Studio 2017 .


### *Общая структура проекта*

Структура проекта:
- `img` — директория с изображениями, используемых в отчете к лабораторной работе. 
- `include` — директория для размещения заголовочных файлов.
- `samples` — директория для размещения тестового приложения.
- `build` — директория с файлами решений и проектов для Visual Studio 2017
- `src` — директория для размещения исходных кодов (cpp-файлы).
- `README.md` — отчет о выполненной лабораторной работе.
- Служебные файлы
    - `.gitignore` — перечень расширений файлов, игнорируемых Git при добавлении файлов в репозиторий.


### *Описание структуры программы*
- `Unit` — описывает сущность "узел" списка. "Узел" хранит в себе значение "ключа" и указатель на следующий узел, то есть на объект такого же класса.
- `List` — класс "список", агрегирующий в себе класс *`Unit`*.
- `Stack`* — класс "стек", агрегирующий в себе класс *`List`*.
- `postfix_lib` — статическая библиотека, использующая функционал класса *`Stack`*, содержащая класс *`Postfix`* со статическими методами перевода арифметического выражения из инфиксной формы в постфиксную и вычисления полученного выражения. Содержит 2 метода
	- `gen_form` — метод непосредственного перевода выражения в постфиксную запись, учитывающая корректность данных. Входные и выходные данные — строковый тип.
	- `calc_form` — метод вычисления результата, считывающая аргументы арифметического выражения из потока данных. Входные данные — строковый тип (выражение в постфиксной форме), выходные — вещественное число. Так же учитывает корректность введенных данных, и соответствие количества операндов и операций.
- `main` — консольное приложение, содержащее функцию `main`, которая запрашивает у пользователя выражение в инфиксной записи и выводит выражение в постфиксной форме и результат, полученные от функций библиотеки `postfix_lib`.

### *Описание структур данных*

#### Структура данных "список"

Односвязный линейный список — динамическая структура данных, состоящая из однотипных "узлов", каждый из которых содержит данные определенного типа и указатель на последующий узел списка. Указатель последнего элемента списка равен нулю, что является признаком конца списка. Указателем на список является указатель на его первый элемент (root).

![list](/img/list.png)

Принципиальным преимуществом перед линейным массивом является структурная гибкость: порядок элементов связного списка может не совпадать с порядком расположения элементов данных в памяти компьютера, а порядок обхода списка всегда явно задаётся его внутренними связями.

В данной лабораторной работе структура данных "список" представлена в виде класса *`List`*, который содержит в себе следующие методы:

- Конструктор по умолчанию.
- Конструктор копирования списков.
- Деструктор.
- `erase` — перегруженный метод удаления элемента с заданным ключом или по указателю на элемент.
- `push_up` — метод создания элемента с заданным ключом и вставки его в начало списка.
- `push_back` — метод создания элемента с заданным ключом и вставки его в конец списка.
- `push_under` — метод вставки элемента, на который передан указатель, до элемента с заданным ключом.
- `pop_back` — метод удаления элемента из конца списка, возвращает ключ элемента.
- `pop_up` — метод удаления из начала списка, возвращает ключ.
- `get_size` — метод возвращает количество элементов списка
- Оператор равенства перегружен для правильного присваивания.


Класс *`List`* реализован с использованием шаблонов для покрытия его использования с различными типами данных.

#### Структура данных "стек"

Стек — динамическая структура данных, представляющая собой список элементов, организованных по принципу FILO (англ. first in — last out, «последним пришёл — первым вышел»).

В данной лабораторной работе структура данных "стек" реализована в виде односвязного линейного списка, то есть каждый элемент содержит помимо хранимой информации в стеке указатель на следующий элемент стека. 

![stack](/img/stack.png)

Программный вид стека используется для обхода структур данных, например, дерево или граф. При использовании рекурсивных функций также будет применяться стек, но аппаратный его вид. Кроме этих назначений, стек используется для организации стековой машины, реализующей запись и вычисления в постфиксной форме арифметических выражений (последний алгоритмы реализован в данной лабораторной работе в качестве примера использования стеков).

В данной лабораторной работе структура данных "стек" представлена в виде класса *`Stack`*, который агрегирует в себя объект класса *`List`* и содержит следующие методы:

- Конструктор по умолчанию, который явно вызывает конструктор класса *`List`*.
- Конструктор копирования.
- Деструктор.
- `empty` — метод проверки стека на пустоту
- `full` — метод проверки стека на полноту. По факту, проверяется наличие доступной памяти в виртуальном адресном пространстве программы для создания нового узла списка.
- `push` — метод добавления элемента с заданным значением на вершину стека.
- `pop` — метод изъятия элемента с вершины стека. Метод возвращает значение элемента.

Класс *`Stack`* реализован с использованием шаблонов для покрытия его использования с различными типами данных.


### *Описание алгоритмов*

#### Алгоритм перевода в постфиксную запись

Описание алгоритма перевода из инфиксной записи в постфиксную:

1. Каждой операции ставится приоритет

	- Операциям умножения `*` и деления `/` наивысший приоритет, равный 3.
	- Операциям сложения `+` и вычитания `-` приоритет 2
	- Операции открывающей скобки `(` приоритет 1.
	- Операции равенства `=` приоритет 0.

2. Создается 2 стека: стек для хранения текущей постфиксной формы `Stack_one` и стек для хранения операций `Stack_two`.
3. Выражение просматривается слева-направо, при этом возможно 4 случая:

	1. Встретился операнд. Тогда он добавляется в стек `Stack_one`.
	2. Встретилась операция, приоритет которой выше, чем приоритет операции, лежащей на вершине стека `Stack_two`, или стек `Stack_two` пуст. В этом случае операция добавляется в стек для хранения операций `Stack_two`.
	3. Встретилась операция, приоритет которой равен или ниже приоритета операции, лежащей на вершине стека `Stack_two`. В этом случае все операции, приоритет которых больше данной перекладываются в стек `Stack_one` до тех пор, пока на вершине стека `Stack_two` не появится операции с меньшим приоритетом или `Stack_two` не станет пустым. Новая же операция добавляется в стек хранения операций.
	4. Встретилась операция закрывающей скобки. В этом случае из стека `Stack_two` перекладываются все операции в `Stack_one` до первого вхождения операции открывающей скобки. Операция открывающей скобки удаляется из стека операций.

4. Если выражение закончилось, то все операции из стека операций `Stack_two` перекладываются в стек хранения текущей постфиксной формы `Stack_one`.

#### Алгоритм подсчета выражения в постфиксной записи

Описание алгоритма вычисления арифметического выражения в постфиксной форме:

1. Создается первый стек с вещественным типом данных `double_list`, для сохранения введенных значений пользователя.
2. Выражение просматривается справа на лево.
3. Если встречается операнд, то запрашивается число, которое будет соответствовать этому операнду и добавляется в `double_list`
4. Создается второй стек `end_list`
5. Встретился операнд. В этом случае на вершину стека `end_list` добавляется элемент из вершины`double_list`.
	5. Встретилась операция. Тогда из стека `end_list` изымаются 2 операнда, над ними совершается операция, результат операции снова добавляется в стек.
6. При достижении конца арифметического выражения, в стеке будет находиться единственный элемент — численный результат выражения.

## Заключение
В ходе лабораторной работы была разработана программа, удовлетворяющая поставленным задачам. Структура стек и список были реализованы с использованием шаблонных классов, так как этого требовал алгоритм преобразования записи выражения.

Реализован алгоритм перевода арифметического выражения из инфиксной формы в постфиксную и вычисление его результата.


## Литература

- Лафоре Р — Объектно-ориентированное программирование в С++ — 2016 — 928 с.
- Роберт Мартин — Чистый код: создание, анализ и рефакторинг — 2013 — 464 с.

